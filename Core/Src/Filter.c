#include "Filter.h"
#include <stdint.h>

// 圆周率定义，用于滤波器权重计算
#define PI 3.14159265358979f

/*********************************************************************************
 * @name   LPFilter_init
 * @brief  低通滤波器初始化函数
 * @param  lpf: 指向低通滤波器结构体的指针
 * @param  samplePeriod: 采样周期(秒) - 系统调用滤波器的时间间隔
 * @param  cutFrequency: 截止频率(Hz) - 高于此频率的信号将被衰减
 * @retval 无
 * @note   截止频率越高，滤波器响应越快，但去噪效果越弱
 *         截止频率越低，滤波器响应越慢，但去噪效果越强
 * @example:
 *         // 2ms采样周期，10Hz截止频率的滤波器
 *         LPFilter_init(&my_filter, 0.002f, 10.0f);
 *********************************************************************************/
void LPFilter_Init(s_LPFilter *lpf, float samplePeriod, float cutFrequency)
{
    // 计算滤波器权重系数
    // 公式：α = 1 / (1 + 1/(2π × T × fc))
    // 其中：T = 采样周期, fc = 截止频率
    // 权重范围 [0,1]: 越接近1响应越快，越接近0滤波越强
    float denominator = 2.0f * PI * samplePeriod * cutFrequency;
    lpf->weight = 1.0f / (1.0f + 1.0f / denominator);

    // 初始化启动标志为0，表示滤波器尚未开始工作
    // 首次调用LPFilter()时会进行特殊初始化处理
    lpf->start = 0;
    lpf->pastValue = 0.0f;
}

/*********************************************************************************
 * @name   LPFilter_Process
 * @brief  低通滤波器处理函数
 * @param  lpf: 指向低通滤波器结构体的指针
 * @param  newValue: 新输入值 - 需要进行滤波的原始数据
 * @retval 返回滤波后的输出值
 * @note   首次调用时会自动初始化pastValue为newValue，避免初始偏差
 *         后续调用会根据权重系数进行加权平均计算
 * @example:
 *         float filtered_value = LPFilter_Process(&my_filter, raw_value);
 *********************************************************************************/
float LPFilter_Process(s_LPFilter *lpf, float newValue)
{
    // 首次调用检查：如果滤波器还未启动
    if (!lpf->start)
    {
        // 设置启动标志，表示滤波器已经开始工作
        lpf->start = 1;

        // 首次调用时，直接将输入值作为初始滤波输出
        // 这样避免了从0开始可能导致的初始偏差
        lpf->pastValue = newValue;
    }

    // 低通滤波核心算法：加权平均
    // pastValue = weight × newValue + (1-weight) × pastValue
    // 新数据权重 + 历史数据权重 = 100%
    // weight越大：新数据影响越大，响应越快，滤波效果越弱
    // weight越小：历史数据影响越大，响应越慢，滤波效果越强
    lpf->pastValue = lpf->weight * newValue + (1.0f - lpf->weight) * lpf->pastValue;
    return lpf->pastValue;
}

/*********************************************************************************
 * @name   LPF_clear
 * @brief  清除低通滤波器状态，重置为初始状态
 * @param  lpf: 指向低通滤波器结构体的指针
 * @retval 无
 * @note   调用此函数后，滤波器会忘记所有历史数据
 *         下次调用LPFilter()时会重新进行首次初始化
 * @use_case:
 *         - 传感器重新标定后
 *         - 系统模式切换时
 *         - 检测到数据跳变需要重新开始滤波时
 * @example:
 *         if (sensor_error_detected) {
 *             LPF_clear(&my_filter);  // 清除可能的错误历史数据
 *         }
 *********************************************************************************/
void LPF_clear(s_LPFilter *lpf)
{
    // 重置启动标志，下次调用LPFilter()时会重新初始化
    lpf->start = 0;

    // 清除历史滤波值，避免残留数据影响
    // 虽然下次LPFilter()会重新设置这个值，但清零更安全
    lpf->pastValue = 0.0f;
}

/*********************************************************************************
 * 使用示例和最佳实践：
 *
 * 1. 参数选择建议：
 *    - 角度控制：截止频率 10-20Hz（需要较快响应）
 *    - 速度控制：截止频率 5-15Hz（平衡响应与平滑）
 *    - 距离测量：截止频率 1-5Hz（噪声大，需要强滤波）
 *
 * 2. 注意事项：
 *    - 采样周期必须与实际调用频率一致
 *    - 截止频率不能超过奈奎斯特频率（采样频率的一半）
 *    - 滤波会引入相位延迟，高精度控制时需要考虑
 *********************************************************************************/

/*********************************************************************************
 * @name   kalman_init
 * @brief  卡尔曼滤波器初始化函数
 * @param  kf: 指向卡尔曼滤波器结构体的指针
 * @param  q: 过程噪声协方差 - 系统模型的不确定性
 * @param  r1: 传感器1测量噪声协方差 - 传感器1的精度
 * @param  r2: 传感器2测量噪声协方差 - 传感器2的精度
 * @param  initial_value: 状态初始值 - 系统状态的初始估计
 * @retval 无
 * @note   参数调优指导：
 *         - q越大：系统变化越快，滤波器更相信测量值，响应更快
 *         - q越小：系统变化越慢，滤波器更相信预测值，更稳定
 *         - r越大：传感器越不可靠，滤波器会降低该传感器的权重
 *         - r越小：传感器越可靠，滤波器会提高该传感器的权重
 * @example:
 *         // 位置融合：LiDAR精度高(r1=1.0)，码盘精度低(r2=5.0)，系统变化适中(q=0.1)
 *         kalman_init(&position_filter, 0.1f, 1.0f, 5.0f, 0.0f);
 *********************************************************************************/
void kalman_init(KalmanFilter *kf, float q, float r1, float r2, float initial_value)
{
    // 过程噪声协方差：反映系统模型的不确定性
    // 在位置估计中，这反映了机器人运动模型的误差
    kf->q = q;

    // 测量噪声协方差：反映传感器的测量精度
    // r1, r2分别对应两个传感器的噪声水平
    // 值越小表示传感器越可靠，在融合时权重越大
    kf->r1 = r1; // 传感器1噪声协方差（例如：LiDAR）
    kf->r2 = r2; // 传感器2噪声协方差（例如：码盘）

    // 后验估计协方差：反映当前状态估计的不确定性
    // 初始值设为1.0，表示对初始状态有一定信心但不是绝对确定
    kf->p = 1.0f;

    // 状态估计：系统要估计的真实值（如位置、速度等）
    kf->x = initial_value;

    // 初始化预测阶段的中间变量
    kf->x_ = 0.0f;          // 先验状态估计
    kf->p_ = 0.0f;          // 先验协方差估计
    kf->k1 = kf->k2 = 0.0f; // 卡尔曼增益
}

/*********************************************************************************
 * @name   kalman_filter_update
 * @brief  双传感器卡尔曼滤波器更新函数
 * @param  kf: 指向卡尔曼滤波器结构体的指针
 * @param  data1: 传感器1的测量值（例如：LiDAR位置数据）
 * @param  data2: 传感器2的测量值（例如：码盘位置数据）
 * @retval 无，融合结果存储在kf->x中
 * @note   卡尔曼滤波的核心思想：
 *         通过预测和修正两个步骤，融合多个传感器数据
 *         自动调整各传感器权重，实现最优估计
 * @algorithm:
 *         1. 预测阶段：基于系统模型预测下一状态
 *         2. 更新阶段：用测量值修正预测结果
 *         3. 重复以上过程，不断优化估计精度
 *********************************************************************************/
void kalman_filter_update(KalmanFilter *kf, float data1, float data2)
{
    /*==========================================================================
     *                            第一步：预测阶段（时间更新）
     * 基于系统动力学模型预测当前时刻的状态
     * 这里假设系统模型为：x(k) = x(k-1)，即状态保持不变（静态模型）
     * 对于运动系统，可以改为：x(k) = x(k-1) + v(k-1)*dt + 0.5*a*dt^2
     *==========================================================================*/

    // 先验状态估计：基于上一时刻的后验估计预测当前状态
    // 这里使用最简单的模型：状态不变
    // 在实际应用中，可以根据运动模型进行更复杂的预测
    kf->x_ = kf->x; // x_(k|k-1) = x(k-1|k-1)

    // 先验协方差估计：预测当前状态估计的不确定性
    // 由于系统存在过程噪声，不确定性会增加
    kf->p_ = kf->p + kf->q; // P_(k|k-1) = P(k-1|k-1) + Q

    /*==========================================================================
     *                            第二步：更新阶段（测量更新）
     * 使用传感器测量值修正预测结果
     *
     * 卡尔曼滤波的精髓：自动计算最优权重
     * - 如果预测不确定性大，更相信测量值
     * - 如果测量噪声大，更相信预测值
     * - 权重由卡尔曼增益K自动调节
     *==========================================================================*/

    /*--------------------------------------------------------------------------
     * 传感器1更新（例如：LiDAR数据融合）
     *--------------------------------------------------------------------------*/

    // 计算卡尔曼增益K1：决定传感器1测量值的权重
    // K = P_先验 / (P_先验 + R_测量噪声)
    // 当P_大（预测不确定）时，K接近1，更相信测量值
    // 当R_大（测量噪声大）时，K接近0，更相信预测值
    kf->k1 = kf->p_ / (kf->p_ + kf->r1);

    // 状态更新：融合预测值和测量值
    // x_后验 = x_先验 + K * (测量值 - x_先验)
    // 这是一个加权平均：K决定测量值的权重，(1-K)决定预测值的权重
    kf->x = kf->x_ + kf->k1 * (data1 - kf->x_);

    // 协方差更新：计算融合后状态估计的不确定性
    // P_后验 = (1 - K) * P_先验
    // 融合测量值后，不确定性必然减小
    kf->p = (1.0f - kf->k1) * kf->p_;

    /*--------------------------------------------------------------------------
     * 传感器2更新（例如：码盘数据融合）
     *
     * 注意：这里使用串行更新方式
     * 先用传感器1更新，再基于更新结果用传感器2继续更新
     * 这样可以充分利用两个传感器的信息
     *--------------------------------------------------------------------------*/

    // 计算传感器2的卡尔曼增益
    // 注意：这里使用传感器1更新后的协方差kf->p
    kf->k2 = kf->p / (kf->p + kf->r2);

    // 使用传感器2的测量值进一步更新状态估计
    // 基于传感器1更新后的结果继续优化
    kf->x = kf->x + kf->k2 * (data2 - kf->x);

    // 最终协方差更新
    // 经过两次传感器更新，状态估计的不确定性进一步降低
    kf->p = (1.0f - kf->k2) * kf->p;

    /*==========================================================================
     * 算法总结：
     *
     * 1. 预测阶段增加不确定性（+q）
     * 2. 每次测量更新都减少不确定性（×(1-k)）
     * 3. 卡尔曼增益k自动平衡预测值和测量值的权重
     * 4. 最终得到比任何单一传感器都更准确的融合结果
     *
     * 数学原理：
     * 卡尔曼滤波器在最小均方误差意义下是最优的线性滤波器
     * 它能在有噪声的环境中提供对系统状态的最佳估计
     *==========================================================================*/
}

/*********************************************************************************
 * 使用示例和参数调优建议：
 *
 * 1. 位置融合应用（LiDAR + 码盘）：
 *    kalman_init(&pos_filter, 0.1f, 1.0f, 5.0f, 0.0f);
 *    - q=0.1: 位置变化适中
 *    - r1=1.0: LiDAR精度高
 *    - r2=5.0: 码盘精度相对较低
 *
 * 2. 角度融合应用（陀螺仪 + LiDAR角度）：
 *    kalman_init(&angle_filter, 0.01f, 0.5f, 2.0f, 0.0f);
 *    - q=0.01: 角度变化缓慢
 *    - r1=0.5: 陀螺仪短期精度高
 *    - r2=2.0: LiDAR角度精度适中
 *
 * 3. 参数调优技巧：
 *    - 开始时设置较大的q值，观察滤波器响应速度
 *    - 根据传感器手册设置r值，精度高的传感器r值小
 *    - 通过实际测试数据调整参数，观察滤波效果
 *    - 可以动态调整q值：运动时增大，静止时减小
 *
 * 4. 常见问题和解决方案：
 *    - 滤波器响应太慢：增大q或减小r
 *    - 滤波器不够平滑：减小q或增大r
 *    - 某个传感器权重过大：调整对应的r值
 *    - 初始收敛慢：适当增大初始p值
 *********************************************************************************/
